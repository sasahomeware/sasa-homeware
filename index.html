<!DOCTYPE html>
<html>
<head>
  <title>SASA Interiors AR Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.4.0/model-viewer.min.js"></script>
  <style>
    /* Custom slider styling */
    #tiling-scale-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #007bff;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    #tiling-scale-slider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #007bff;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>

  <model-viewer
      id="main-viewer"
      ar
      ar-modes="webxr scene-viewer quick-look"
      camera-controls
      shadow-intensity="1"
      style="width: 100%; height: 700px;">
      <button slot="ar-button" id="ar-button" style="background-color: white; border-radius: 4px; border: 1px solid black; position: absolute; bottom: 16px; right: 16px; padding: 10px 15px; cursor: pointer;">
          View in your room
      </button>
  </model-viewer>
  
  <!-- Material Controls Section -->
  <div id="material-controls" style="padding: 16px; background-color: #f9f9f9; border-top: 1px solid #ddd; font-family: Arial, sans-serif;">
    <div style="display: flex; align-items: center; gap: 24px; flex-wrap: wrap;">
        <div style="display: flex; align-items: center; gap: 12px;">
            <span style="font-size: 14px; font-weight: 500; color: #555;">Choose a Fabric:</span>
            <div id="fabric-controls" style="display: flex; gap: 8px;"></div>
        </div>
        <div style="display: flex; align-items: center; gap: 12px;">
            <span style="font-size: 14px; font-weight: 500; color: #555;">Tiling Scale:</span>
            <div style="display: flex; align-items: center; gap: 8px;">
                <input id="tiling-scale-slider" type="range" min="0.1" max="5.0" step="0.1" value="1.0" 
                       style="width: 120px; height: 6px; background: #ddd; border-radius: 3px; outline: none; cursor: pointer; -webkit-appearance: none; appearance: none; background: linear-gradient(to right, #007bff 0%, #007bff 0%, #ddd 0%, #ddd 100%);">
                <span id="texture-scale-display" style="font-size: 12px; color: #666; min-width: 30px; text-align: center;">1.0</span>
            </div>
        </div>
    </div>
  </div>

  <script>
    const modelViewer = document.querySelector('#main-viewer');
    const params = new URLSearchParams(window.location.search);
    const glbSrc = params.get('glb');

    if (glbSrc) {
        modelViewer.src = glbSrc;
    }

    window.history.replaceState(
    {}, 
    document.title, 
    window.location.pathname
  );

    let currentTextureScale = 1.0;
    // --- CACHING: Object to store our pre-created textures ---
    const textureCache = {};

    const fabricSets = {
        'leather': {
            name: 'Brown Leather',
            color: './Leather037_2K-PNG_Color.png',
            normal: './Leather037_2K-PNG_NormalGL.png',
            roughness: './Leather037_2K-PNG_Roughness.png',
        },
        'carpet': {
            name: 'Carpet',
            color: './Carpet016_4K-PNG/Carpet016_4K-PNG_Color.png',
            normal: './Carpet016_4K-PNG/Carpet016_4K-PNG_NormalGL.png',
            roughness: './Carpet016_4K-PNG/Carpet016_4K-PNG_Roughness.png',
            // --- FIX: Commented out the problematic AO map ---
            // ao: './Carpet016_4K-PNG/Carpet016_4K-PNG_AmbientOcclusion.png'
        }
    };

    // --- CACHING: This function now applies textures from the cache, making it instant ---
    function applyPBRTextureSet(material, cachedTextures) {
        if (cachedTextures.color) material.pbrMetallicRoughness.baseColorTexture.setTexture(cachedTextures.color);
        if (cachedTextures.normal) material.normalTexture.setTexture(cachedTextures.normal);
        if (cachedTextures.roughness) material.pbrMetallicRoughness.metallicRoughnessTexture.setTexture(cachedTextures.roughness);
        // The AO texture will no longer be applied since it's removed from the cache logic
        if (cachedTextures.ao) material.occlusionTexture.setTexture(cachedTextures.ao);
        
        updateAllMaterialScales();
    }

    function setTextureScale(textureInfo, scale) {
        if (textureInfo && textureInfo.texture && textureInfo.texture.sampler) {
            textureInfo.texture.sampler.setScale({ u: scale, v: scale });
        }
    }

    function updateAllMaterialScales() {
        const model = modelViewer.model;
        if (!model) return;
        
        model.materials.forEach(material => {
            setTextureScale(material.pbrMetallicRoughness.baseColorTexture, currentTextureScale);
            setTextureScale(material.normalTexture, currentTextureScale);
            setTextureScale(material.pbrMetallicRoughness.metallicRoughnessTexture, currentTextureScale);
            setTextureScale(material.occlusionTexture, currentTextureScale);
        });
        
        const scaleDisplay = document.getElementById('texture-scale-display');
        if (scaleDisplay) {
            scaleDisplay.textContent = `${currentTextureScale.toFixed(1)}`;
        }
    }
    
    function updateTextureScale() { updateAllMaterialScales(); }

    function addMaterialControls() {
        const model = modelViewer.model;
        if (!model) return;

        const fabricControls = document.getElementById('fabric-controls');
        fabricControls.innerHTML = '';

        for (const key in fabricSets) {
            const fabricSet = fabricSets[key];
            const fabricBtn = document.createElement('button');
            fabricBtn.innerText = fabricSet.name;
            fabricBtn.style.cssText = `padding: 8px 14px; border: 2px solid #ddd; border-radius: 20px; background-color: #fff; cursor: pointer;`;
            
            // --- CACHING: The onclick event is now much simpler ---
            fabricBtn.onclick = () => {
                // Check if the textures for this button are in the cache
                if (textureCache[key]) {
                    // Instantly apply the cached textures to all materials
                    model.materials.forEach(material => {
                        applyPBRTextureSet(material, textureCache[key]);
                    });

                    // Update button styles
                    fabricControls.querySelectorAll('button').forEach(btn => btn.style.borderColor = '#ddd');
                    fabricBtn.style.borderColor = '#007bff';
                } else {
                    console.log(`Textures for ${fabricSet.name} not cached yet.`);
                }
            };
            fabricControls.appendChild(fabricBtn);
        }
        
        const tilingSlider = document.getElementById('tiling-scale-slider');
        if (tilingSlider) {
            tilingSlider.addEventListener('input', (e) => {
                currentTextureScale = parseFloat(e.target.value);
                updateTextureScale();
            });
        }
    }

    // --- CACHING: Main event listener now pre-loads and caches all textures ---
    modelViewer.addEventListener('load', async () => {
        const model = modelViewer.model;
        if (!model) return;

        console.log('Model loaded. Pre-caching all textures...');
        
        // Loop through each fabric set and create its textures
        for (const key in fabricSets) {
            const textureSet = fabricSets[key];
            try {
                const [color, normal, roughness, ao] = await Promise.all([
                    modelViewer.createTexture(textureSet.color),
                    modelViewer.createTexture(textureSet.normal),
                    modelViewer.createTexture(textureSet.roughness),
                    // This will now resolve to null for the carpet, preventing an error
                    textureSet.ao ? modelViewer.createTexture(textureSet.ao) : Promise.resolve(null)
                ]);
                
                // Store the created textures in our cache
                textureCache[key] = { color, normal, roughness, ao };
                console.log(`Cached textures for: ${textureSet.name}`);
            } catch (error) {
                console.error(`Failed to cache textures for ${textureSet.name}:`, error);
            }
        }
        
        console.log('All textures cached.');
        
        // Build the UI controls now that everything is ready
        addMaterialControls();

        // Apply the first texture set by default from the cache
        const firstKey = Object.keys(fabricSets)[0];
        if (firstKey && textureCache[firstKey]) {
            model.materials.forEach(material => {
                applyPBRTextureSet(material, textureCache[firstKey]);
            });
            // Highlight the first button
            const firstButton = document.querySelector('#fabric-controls button');
            if (firstButton) {
                firstButton.style.borderColor = '#007bff';
            }
        }
    }, { once: true });

  </script>

</body>
</html>
